% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/profLik.R
\name{profLik.default}
\alias{profLik.default}
\title{Profile-Likelihood Inference for Fitted Parametric Model
Objects}
\usage{
\method{profLik}{default}(object,
        fun,
        level = 0.95,
        deriv = TRUE,
        trace = 0,
        diagno = TRUE,
        ftol_abs = 1e-12, ftol_rel = 1e-8,
        ...)
}
\arguments{
\item{object}{A fitted model object. See \bold{Details}.}

\item{fun}{A function of the parameter vector for which the
profile-likelihood will be carried over. This function must have
the arguments: \code{theta} for the vector of parameters and
\code{object} for the model object; so the function can use the
velue of some of slots of \code{object} see \bold{Details}. The
function must return a list with two elements with names
\code{"objective"} and \code{"gradient"} as required by
\code{\link[nloptr]{nloptr}} see \bold{Examples}. If needed, a
wrapper function can be used to use more arguments.}

\item{level}{Level of confidence. Can be of length \code{> 1}.}

\item{deriv}{Logical. If \code{TRUE}, the function \code{fun} is
assumed to provide a gradient vector as an attribute named
\code{"gradient"} of the result. For now \code{deriv} can only be
\code{TRUE}, which implies that \code{fun} \emph{must} compute the
gradient.}

\item{trace}{Level of verbosity; the value \code{0} prints
nothing.}

\item{diagno}{Logical. When \code{TRUE} two diagnostics are
returned as two attributes \code{"diagno"} and \code{"theta"} of
the returned array. The array in attribute \code{"diagno"}
contains the return codes of \code{nloptr} (named
\code{"status"}), the values of the objective and of the
constraint functions as well as a value named \code{"gradDist"}
whcih measures the distance between the two directions of the two
gradients: objective and constraint.  The array in attribute
\code{"theta"} contains the value of the Poisson-GP parameter that
was found to maxi/minimise the function \code{fun} under the
constraint of a high log-likelihood. See section \bold{Note}.}

\item{ftol_abs, ftol_rel}{Absolute and relative tolerance to stop
the constrained optimisation \code{\link[nlopr]{nloptr}}. These
apply to the objective of the constrained optimisation that is to
the value of \code{fun}. Remind that \code{ftol_abs} is thus given
with the same unit as \code{fun}.}

\item{...}{Not used yet.}
}
\value{
An array with the value of the function and the
corresponding Lower and Upper end-points for the given confidence
levels. This array has two attributes with names \code{"diagno"}
and \code{"psi"} which both are arrays. The attributes provide
information about the numerical optimisation and the values of the
vector of parameter that maximised or minimised the function
\code{fun}.
}
\description{
Profile-likelihood inference for fitted model objects.
}
\details{
Compute the lower and upper end-points of a
profile-likelihood based confidence interval. The (apparently new)
method used here relies on maximising and minimising the function
of interest, say \eqn{\eta(\boldsymbol(\theta)}{\eta(\theta)},
under the constraint that the log-likelihood is greater than the
maximal log-likelihood minus a positive quantity \eqn{\delta}
depending on the confidence level. This differs from the usual
method which relies on an univariate zero-finding for the
profile-likelihood function (minus a constant). Remind that each
evaluation of the profile requires a \eqn{p-1} dimensional
optimisation. As a major advantage, the new method does not
require a re-parameterisation of the model.

The requirement for the method to work is that \code{object} has
suitable "slots", i.e. is a list with suitable elements. These
are: the number \code{p} of parameters, the vector \code{parNames}
of the parameter names, the vector \code{estimate} of ML
estimates, the closure \code{negLogLikFun} computing the negative
log-likelihood function and the value \code{negLogLik} of the
minimised negative log-likelihood. These requirements are
fulfilled for \code{\link{poisGP}} objects of the package. The
result returned by \code{object$negLogLikFun} should have a
\code{"gradient"} attribute to allow the use of derivatives.
}
\note{
For each confidence limit the numerical optimisation may
fail, in which case the limit will be \code{NA}. Using \code{trace
= 1} can be useful to further check the optimisation. We encourage
the user to inspect the set of important diagnostics returned when
\code{diagno = TRUE}, especially those in the attribute of the
result named \code{"diagno"}. The \emph{optimisation status} value
in \code{status} should be between \code{1} and \code{4} to
indicate that small changes on the parameter or on the objective
were eventually obtained. On the other hand, a value of \code{5}
for \code{status} indicates that the maximal number of iterations
was reached, which is considered here as a failure. Both the
\code{constraint} and \code{gradDist} values should be small
because the constraint must be active at the optimum and the two
gradients for the objective and the constraint must be colinear at
the optimum (Lagrange conditions). In other words the optimum
parameter vector must lie on the boundary of the high-likelihood
region corresponding to the chosen confidence level.
}
\examples{
object <- poisGP(Garonne)

## =========================================================================
## Define a function of the parameter vector: here the first component of
## the "PP" parameter vector.
## This is for code illustration only, since the the result can be obtained
## using the 'confint' method with 'method = "proflik"', which
## gives the profile-likelihood confidence intervals for each of the
## three parameters.
## =========================================================================

numPP <- 2
myfun <- function(theta, object) {
    thetaStar <- poisGP2PP(lambda = theta[1], scale = theta[2], shape = theta[3],
                           loc = object$threshold, deriv = TRUE)
    res <- thetaStar[numPP]
    grad <- attr(thetaStar, "gradient")[1, numPP, c(1, 3, 4)]
    attr(res, "gradient") <- grad
    res
}

pl <- profLik(object = object, fun = myfun, level = c(0.95, 0.70))

}
\references{
Deville Y. (2017) "Profile-Likelihood Using Constrained
Optimisation". Unpublished Tech. Report.

Johnson S.G. \emph{The NLopt Nonlinear-Optimization Package}.
\url{http://github.com/stevengj/nlopt}.

Section \bold{Return values} in the manual
\href{https://nlopt.readthedocs.io/en/latest/NLopt_Reference}{NLOPT
Reference}.
}
\seealso{
\code{\link[nloptr]{nloptr}} for details on the
optimisation.
}
\author{
Yves Deville
}
